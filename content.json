{"pages":[],"posts":[{"title":"首次调接口超时问题","text":"本文记录首次调接口的超时问题，阐述相应的问题分析，最终给出的解决方案。 问题描述服务A调用服务B接口超时，但之后调用接口就正常了。具体打印的日志如下：服务A后台在47秒时收到页面请求，并调用服务B接口，由于接口调用超时，服务A在53秒时打印出异常。而服务B在55s才收到本次的请求，并返回结果。服务A日志1234562019-01-23T13:41:47.791+08:00 INFO issc.issc [http-nio-8080-exec-58] [c.h.i.s.service.impl.UserExperiencePlanServiceImpl:58] - begin get user experience plan2019-01-23T13:41:53.185+08:00 ERROR issc.issc [http-nio-8080-exec-58] [c.h.i.sysconfig.exception.GlobalExceptionHandler:147] [0x06d00003] - unknown error ...Caused by: java.net.SocketTimeoutException: Read timed out at java.net.SocketInputStream.socketRead0(Native Method) ... 服务B日志122019-01-23T13:41:55.099+08:00 INFO reportservice.reportservice [http-nio-8080-exec-49] [c.h.r.module.controller.ReportSwitchController:55] - getSwitch() start!... 问题分析通过日志排查，发现问题是发生在服务B重启后的第一次接口调用，在网上搜索后发现，在DispatcherServlet没有配置load-on-startup情况下，只有当实际访问请求到来时，应用服务器才会加载DispatcherServlet，而DispatcherServlet初始化要耗费一些时间，很有可能导致接口超时。 解决方式在服务B的web.xml中，DispatcherServlet配置增加load-on-startup，表明在应用启动时将加载并初始化DispatcherServlet。 123456789&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;","link":"/2019/01/25/首次调接口超时问题/"},{"title":"spring in action之bean装配","text":"本文介绍了sping in action之bean装配，内容包括自动扫描、Java代码装配、xml装配、选择哪种装配方式最合适以及项目中犯过的错误等。 sping in action之bean装配 自动扫描 Java代码装配 xml装配 选择哪种装配方式最合适？ 项目中犯过的错误 自动扫描User类ComponentScan注解在spring中启用组件扫描，默认扫描与配置类相同的包，查找带有Component注解的类。也可以通过xml配置启用组件扫描。1234567package spring.di.componentScan.dto;@Configuration@ComponentScanpublic class User { } Role类Component注解表明该类会作为组件类，并告知spring要为这个类创建bean。 123456package spring.di.componentScan.dto;@Componentpublic class Role{} 测试类 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=User.class)public class BeanTest { @Autowired private Role role; @Test public void roleNotNull(){ assertNotNull(role); }} 单元测试能够通过，成功创建了Role的bean实例，默认的实例ID为role，也就是将类名的第一个字母变为小写，可以使用@Component(“reNameRole”)将ID修改为reNameRole。 这种方式需要在类上添加@Component和@Autowired注解，如果需要将第三方库中的组件装配到应用中，就需要采用显示装配方式：JavaConfig装配或xml装配。 JavaConfig装配User类Configuration注解表明该类是一个配置类，应该包含在spring应用上下文中如何创建bean的细节。可以将配置类放到单独的包中，使它与业务逻辑分离开。Bean注解告诉spring，这个方法将会返回一个对象，该对象要注册为sprig应用上下文中的bean。bean的默认ID与方法名一样，本例中bean的ID为getRole，可以使用@Bean(“reNameRole”)将ID修改为reNameRole。 1234567@Configurationpublic class User { @Bean public Role getRole(){ return new Role(); }} Role类123public class Role{} xml装配User类 12345678910package spring.di.xml.dto;public class User { private Role role; public User(Role role){ this.role = role; }} Role类 12345package spring.di.xml.dto;public class Role{} xml配置这里显示地设置了bean的ID，如果没有明确给定ID，默认的ID将会是spring.di.xml.dto.Role#0。 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:c=\"http://www.springframework.org/schema/c\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\"&gt; &lt;bean id=\"role\" class=\"spring.di.xml.dto.Role\"/&gt; &lt;bean id=\"user\" class=\"spring.di.xml.dto.User\" c:role-ref = \"role\"/&gt; &lt;/beans&gt; 测试类 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:application.xml\")public class BeanTest { @Autowired private Role role; @Test public void roleNotNull(){ assertNotNull(role); }} 选择哪种装配方式最合适？根据项目的具体情况来选择，三种装配方式也可以相互搭配使用。我目前所在项目组使用自动装配与xml装配相结合的方式，《spring in action》作者给出了如下建议： 尽可能地使用自动装配，显示配置越少越好。当必须使用显示配置时（比如，有些源码不是由你来维护，而你需要为这些代码配置bean时），推荐使用类型安全并比xml更加强大的JavaConfig装配。最后，只有当你想要使用便利的xml命名空间，并且在JavaConfig中没有同样的实现时，才应使用xml。 项目中犯过的错误因为对bean装配以及bean的默认ID理解不清楚，在项目中犯过一个错误。通过xml配置的方式导入RoleService服务，UserService服务根据ID为”roleService”从上下文获取bean，但是获取的bean为null。如果对bean装配的三种方式理解清楚的话，很容易知道，通过xml配置的方式装配bean时，默认ID为spring.di.sysconfig.service.RoleService#0，所以通过AppContext.getBean(“roleService”)方式获取的bean必定会为null。UserService类 12345@Componentpublic class UserService { private RoleService roleService = AppContext.getBean(\"roleService\"); ...} xml配置 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:c=\"http://www.springframework.org/schema/c\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\"&gt; &lt;bean class=\"spring.di.sysconfig.service.RoleService\"/&gt; &lt;/beans&gt;","link":"/2019/01/25/spring-in-action之bean装配/"},{"title":"单元测试","text":"本文介绍了Junit + powermock + mockito单元测试方案。 Junit + powermock + mockito单元测试","link":"/2019/01/26/单元测试/"}],"tags":[{"name":"接口超时","slug":"接口超时","link":"/tags/接口超时/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"bean","slug":"bean","link":"/tags/bean/"},{"name":"单元测试","slug":"单元测试","link":"/tags/单元测试/"},{"name":"powermock","slug":"powermock","link":"/tags/powermock/"},{"name":"mockito","slug":"mockito","link":"/tags/mockito/"}],"categories":[{"name":"后端","slug":"后端","link":"/categories/后端/"}]}