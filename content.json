{"pages":[],"posts":[{"title":"首次调接口超时问题","text":"本文记录首次调接口的超时问题，阐述相应的问题分析，最终给出的解决方案。 Spring配置导致的接口超时问题问题描述服务A调用服务B接口超时，但之后调用接口就正常了。具体打印的日志如下：服务A后台在47秒时收到页面请求，并调用服务B接口，由于接口调用超时，服务A在53秒时打印出异常。而服务B在55s才收到本次的请求，并返回结果。服务A日志1234562019-01-23T13:41:47.791+08:00 INFO issc.issc [http-nio-8080-exec-58] [c.h.i.s.service.impl.UserExperiencePlanServiceImpl:58] - begin get user experience plan2019-01-23T13:41:53.185+08:00 ERROR issc.issc [http-nio-8080-exec-58] [c.h.i.sysconfig.exception.GlobalExceptionHandler:147] [0x06d00003] - unknown error...Caused by: java.net.SocketTimeoutException: Read timed out at java.net.SocketInputStream.socketRead0(Native Method)... 服务B日志122019-01-23T13:41:55.099+08:00 INFO reportservice.reportservice [http-nio-8080-exec-49] [c.h.r.module.controller.ReportSwitchController:55] - getSwitch() start!... 问题分析通过日志排查，发现问题是发生在服务B重启后的第一次接口调用，在网上搜索后发现，在DispatcherServlet没有配置load-on-startup情况下，只有当实际访问请求到来时，应用服务器才会加载DispatcherServlet，而DispatcherServlet初始化要耗费一些时间，很有可能导致接口超时。 解决方式在服务B的web.xml中，DispatcherServlet配置增加load-on-startup，表明在应用启动时将加载并初始化DispatcherServlet。 123456789&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; data source配置导致的接口超时问题问题描述服务启动之后的第一次请求（查询数据库）处理时间较长，对于调用方来说，接口超时了。postman请求接口时间为900ms左右，日子如下：12345672019-07-05T13:47:05.479+08:00 INFO issc.issc [http-nio-8080-exec-3] [com.*.issc.aspect.LogAdvice:48] - begin getSecurityConfig2019-07-05T13:47:05.493+08:00 INFO issc.issc [http-nio-8080-exec-3] [com.*.issc.sysconfig.service.impl.SysConfigServiceImpl:77] - begin query...2019-07-05T13:47:06.134+08:00 DEBUG issc.issc [http-nio-8080-exec-3] [com.*.issc.sysconfig.dao.SysConfigDao.getByConfigType:159] ==&gt; Prepareing: SELECT conf_code, conf_value FROM tb_sysconfig WHERE conf_type = ?2019-07-05T13:47:06.158+08:00 DEBUG issc.issc [http-nio-8080-exec-3] [com.*.issc.sysconfig.dao.SysConfigDao.getByConfigType:159] ==&gt; Parameters: user[String]2019-07-05T13:47:06.184+08:00 DEBUG issc.issc [http-nio-8080-exec-3] [com.*.issc.sysconfig.dao.SysConfigDao.getByConfigType:159] ==&gt; Total: 22019-07-05T13:47:06.193+08:00 INFO issc.issc [http-nio-8080-exec-3] [com.*.issc.sysconfig.service.impl.SysConfigServiceImpl:85] - end query...2019-07-05T13:47:06.194+08:00 INFO issc.issc [http-nio-8080-exec-3] [com.*.issc.aspect.LogAdvice:55] - end query... 经过本地测试，发现在init-datasource中花费的时间较多。查看durid官方文档，如果想要在项目启动时初始化配置的数据库连接数，需要显示配置或者调用init-method。12345678910&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;DataSourceIssc&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;org.postgresql.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${db.url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${db.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${db.password}&quot;/&gt; &lt;!-- 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;5&quot; / ...&lt;/bean&gt; 但如果数据源配置了init-method=”init”，当数据库异常时，数据源Bean构建失败，将导致组件无法正常启动。这种情况下，在Tomcat启动时可以先查一次数据库，完成数据库连接的初始化配置。1234567891011121314public class WebContextLoaderListener implements ServletContextLinstener { private Logger log = LoggerFactory.getLogger(WebContextLoaderListener.class); @Override public void contextInitialized(ServletContextEvent sce){ try{ IUserSercurityService userSercurityService = (IUserSercurityService) AppContext.getBean(&quot;userSercurityService&quot;); if(userSercurityService != null){ userSercurityService.getUserSercurityConfig(); } } catch(Exception){ log.error(*Log.toLog(ErrorCodeEnum.UNKNOW_ERROR.getCodeStr(), &quot;WebContextLoaderListener init fail&quot;), e); } }}","link":"/2019/01/25/首次调接口超时问题/"},{"title":"spring in action之bean装配","text":"本文介绍了sping in action之bean装配，内容包括自动扫描、Java代码装配、xml装配、选择哪种装配方式最合适以及项目中犯过的错误等。 sping in action之bean装配 自动扫描 Java代码装配 xml装配 选择哪种装配方式最合适？ 项目中犯过的错误 自动扫描User类ComponentScan注解在spring中启用组件扫描，默认扫描与配置类相同的包，查找带有Component注解的类。也可以通过xml配置启用组件扫描。1234567package spring.di.componentScan.dto;@Configuration@ComponentScanpublic class User { } Role类Component注解表明该类会作为组件类，并告知spring要为这个类创建bean。 123456package spring.di.componentScan.dto;@Componentpublic class Role{} 测试类 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes=User.class)public class BeanTest { @Autowired private Role role; @Test public void roleNotNull(){ assertNotNull(role); }} 单元测试能够通过，成功创建了Role的bean实例，默认的实例ID为role，也就是将类名的第一个字母变为小写，可以使用@Component(“reNameRole”)将ID修改为reNameRole。 这种方式需要在类上添加@Component和@Autowired注解，如果需要将第三方库中的组件装配到应用中，就需要采用显示装配方式：JavaConfig装配或xml装配。 JavaConfig装配User类Configuration注解表明该类是一个配置类，应该包含在spring应用上下文中如何创建bean的细节。可以将配置类放到单独的包中，使它与业务逻辑分离开。Bean注解告诉spring，这个方法将会返回一个对象，该对象要注册为sprig应用上下文中的bean。bean的默认ID与方法名一样，本例中bean的ID为getRole，可以使用@Bean(“reNameRole”)将ID修改为reNameRole。 1234567@Configurationpublic class User { @Bean public Role getRole(){ return new Role(); }} Role类123public class Role{} xml装配User类 12345678910package spring.di.xml.dto;public class User { private Role role; public User(Role role){ this.role = role; }} Role类 12345package spring.di.xml.dto;public class Role{} xml配置这里显示地设置了bean的ID，如果没有明确给定ID，默认的ID将会是spring.di.xml.dto.Role#0。 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:c=\"http://www.springframework.org/schema/c\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\"&gt; &lt;bean id=\"role\" class=\"spring.di.xml.dto.Role\"/&gt; &lt;bean id=\"user\" class=\"spring.di.xml.dto.User\" c:role-ref = \"role\"/&gt; &lt;/beans&gt; 测试类 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:application.xml\")public class BeanTest { @Autowired private Role role; @Test public void roleNotNull(){ assertNotNull(role); }} 选择哪种装配方式最合适？根据项目的具体情况来选择，三种装配方式也可以相互搭配使用。我目前所在项目组使用自动装配与xml装配相结合的方式，《spring in action》作者给出了如下建议： 尽可能地使用自动装配，显示配置越少越好。当必须使用显示配置时（比如，有些源码不是由你来维护，而你需要为这些代码配置bean时），推荐使用类型安全并比xml更加强大的JavaConfig装配。最后，只有当你想要使用便利的xml命名空间，并且在JavaConfig中没有同样的实现时，才应使用xml。 项目中犯过的错误因为对bean装配以及bean的默认ID理解不清楚，在项目中犯过一个错误。通过xml配置的方式导入RoleService服务，UserService服务根据ID为”roleService”从上下文获取bean，但是获取的bean为null。如果对bean装配的三种方式理解清楚的话，很容易知道，通过xml配置的方式装配bean时，默认ID为spring.di.sysconfig.service.RoleService#0，所以通过AppContext.getBean(“roleService”)方式获取的bean必定会为null。UserService类 12345@Componentpublic class UserService { private RoleService roleService = AppContext.getBean(\"roleService\"); ...} xml配置 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:c=\"http://www.springframework.org/schema/c\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\"&gt; &lt;bean class=\"spring.di.sysconfig.service.RoleService\"/&gt; &lt;/beans&gt;","link":"/2019/01/25/spring-in-action之bean装配/"},{"title":"单元测试","text":"本文介绍了Junit + powermock + mockito单元测试方案。 Junit + powermock + mockito单元测试","link":"/2019/01/26/单元测试/"},{"title":"组件线程没有关闭导致tomcat无法关闭","text":"本文记录实际项目中使用线程时遇到的相关问题，阐述、分析了产生的问题，最终给出解决方案。 问题描述Tomcat状态监控页面，点击停止按钮，页面一直显示正在停止，后台进程也一直显示正在停止，通过jstack分析，Tomcat关不掉是因为组件线程没有正常关闭导致12345678910111213&quot;pool-5-thread-1&quot; #89 prio=5 os_pion=0 tid=0x000000003561b800 nid=0x1743c waiting on condition [0x000000004413e000] java.lang.Thread.State: TIMED_WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for &lt;0x000000073a308cb0&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039) at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442) at com.*.*.*.notify.consumer.datadictionary.ListenerEventQueue.takeDataDictionary(ListenerEventQueue.java:2039） at com.*.*.*.notify.consumer.datadictionary.DatadictionaryEventConsumer.updateDatadictionary(DatadictionaryEventConsumer.java:62） at com.*.*.*.notify.consumer.datadictionary.AbstractEventConsumer.run(AbstractEventConsumer.java:64） at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) 问题分析12345678910111213141516171819202122232425262728public class WebContextLoaderListener implements ServletContextLinstener { private Logger log = LoggerFactory.getLogger(WebContextLoaderListener.class); private ExecutorService executorService = Executors.newSingleThreadExecutor(); @Override public void contextInitialized(ServletContextEvent sce){ try{ //启动事件消费任务 Map&lt;String, AbstractEventConsumer&gt; eventConsumerList = AppContext.getBeanOfType(AbstractEventConsumer.class); if(MapUtils.isNotEmpty(eventConsumerList)){ for (AbstractEventConsumer consumer : eventConsumerList.values()){ if(consumer != null){ executorService.execute(consumer); } } } } catch(Exception){ log.error(*Log.toLog(ErrorCodeEnum.UNKNOW_ERROR.getCodeStr(), \"WebContextLoaderListener init fail\"), e); } } @Override public void contextDestroyed(ServletContextEvent sce){ //关闭线程池 if(executorService != null &amp;&amp; !executorService .isShutdown()){ executorService.shutdown(); } }} tomcat停止时，有执行销毁线程池操作，但线程并没有关闭。实际是executorService.shutdown()这种关闭线程的方式存在问题； 调用shutdownNow()后，不可以再提交新的task(executorService.execute()操作)，已经提交的将继续执行，当所有线程结束执行当前任务，executorService才会真正关闭。 调用shutdown()后，试图停止当前正在执行的task，并返回尚未执行的task列表。 解决方式123456789101112131415@Overridepublic void contextDestroyed(ServletContextEvent sce){ //关闭线程池 if(executorService != null &amp;&amp; !executorService .isShutdown()){ executorService.shutdown(); try{ if(!executorService.awaitTermination(2, TimeUnit.SECONDS)){ executorService.shutdownNow(); } } catch(InterruptedException e){ executorService.shutdownNow(); } }} 其他问题阿里巴巴的JAva开发手册有这样一条规范： 【强制】 线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。说明：Executors 返回的线程池对象的弊端如下：1） FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。2） CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 Spring core包提供的ThreadPoolTaskExecutor对ThreadPoolExecutor进行了封装处理，项目中线程池配置如下：123456789101112131415161718&lt;bean id=&quot;consumerThreadPool&quot; class=&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;&gt; &lt;!-- 线程池的名称前缀 --&gt; &lt;property name=&quot;threadNamePrefix&quot; value=&quot;issc-mq-message-consumer-threadpool-&quot; /&gt; &lt;!-- 设置为守护线程 --&gt; &lt;property name=&quot;daemon&quot; value=&quot;true&quot; /&gt; &lt;!-- 线程池维护线程的最少数量 --&gt; &lt;property name=&quot;corePoolSize&quot; value=&quot;5&quot; /&gt; &lt;!-- 线程池维护线程的最大数量 --&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;10&quot; /&gt; &lt;!-- 缓存队列的长度 --&gt; &lt;property name=&quot;queueCapacity&quot; value=&quot;10&quot; /&gt; &lt;!-- 允许的空闲时间 --&gt; &lt;property name=&quot;keepAliveSeconds&quot; value=&quot;90&quot; /&gt; &lt;!-- 对拒绝task的处理策略 --&gt; &lt;property name=&quot;rejectedExecutionHandler&quot;&gt; &lt;bean class=&quot;java.util.concurrent.ThreadPoolExecutor$AbortPolicy&quot; /&gt; &lt;/property&gt;&lt;/bean&gt; ThreadPoolTaskExecutor的处理流程： 当线程数量小于corePoolSize，新建线程处理请求 当线程数量等于corePoolSize，把请求放入blockingQueue中，线程池中的空闲线程从blockingQueue中获取任务并处理 当blockingQueue满了，会新建线程处理请求，如果线程数量等于maxPoolSize，使用rejectedExecutionHandler做拒绝处理 当线程数量大于corePoolSize时，多于的线程会等待keepAliveSeconds时间，如果无请求处理就自行销毁 修改后代码如下，设置为守护线程后，tomcat关闭时无需手动关闭线程。1234567891011121314151617181920212223public class WebContextLoaderListener implements ServletContextLinstener { private Logger log = LoggerFactory.getLogger(WebContextLoaderListener.class); @Override public void contextInitialized(ServletContextEvent sce){ try{ //启动事件消费任务 TaskExecutor consumerThreadPool= AppContext.getBean(&quot;consumerThreadPool&quot;); if(consumerThreadPool != null){ Map&lt;String, AbstractEventConsumer&gt; eventConsumerList = AppContext.getBean(AbstractEventConsumer.class); if(MapUtils.isNotEmpty(eventConsumerList)){ for (AbstractEventConsumer consumer : eventConsumerList.values()){ if(consumer != null){ executorService.execute(consumer); } } } } } catch(Exception){ log.error(*Log.toLog(ErrorCodeEnum.UNKNOW_ERROR.getCodeStr(), &quot;WebContextLoaderListener init fail&quot;), e); } }}","link":"/2019/07/06/组件线程没有关闭导致Tomcat无法关闭/"}],"tags":[{"name":"接口超时","slug":"接口超时","link":"/tags/接口超时/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"bean","slug":"bean","link":"/tags/bean/"},{"name":"单元测试","slug":"单元测试","link":"/tags/单元测试/"},{"name":"powermock","slug":"powermock","link":"/tags/powermock/"},{"name":"mockito","slug":"mockito","link":"/tags/mockito/"},{"name":"线程","slug":"线程","link":"/tags/线程/"},{"name":"tomcat","slug":"tomcat","link":"/tags/tomcat/"}],"categories":[{"name":"后端","slug":"后端","link":"/categories/后端/"}]}